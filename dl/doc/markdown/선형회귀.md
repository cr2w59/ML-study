

## 최소 제곱법

- method of least squares

-  `y = ax + b`의 기울기 a와 y절편 b를 구할 수 있다.


$$
  a = {\frac{\sum_{=1}^N(x_i-mean(x))(y_i-mean(y))}{\sum_{i=1}^N(x_i-mean(x))^2}}\\ = {\frac{(x-x평균))(y-y평균)의 합}{(x-x평균)^2의 합}}
$$

$$
  b = {mean(y) - (mean(x)*a)}\\ = {y의 평균-(x의 평균*기울기a)}
$$

```python

```



## 평균 제곱근 오차(RMSE)

### 평균 제곱 오차(MSE)

- mean square error
  $$
  MSE = {\frac{1}{N}\sum_{i=1}^N(y_i-p_i)^2}
  $$
  

------

### 평균 제곱근 오차(RMSE)

$$
RMSE = \sqrt{\frac{1}{N}\sum_{i=1}^N(y_i-p_i)^2}
$$

- root mean square error
- **오차 평가 알고리즘**
- MSE는 대용량 데이터를 이용할 때 계산 속도가 느려질 수 있다. 그래서 여기에 제곱근을 씌워 준다.
- 선형 회귀란 임의의 직선에 대한 RMSE 값을 가장 작게 만들어 주는 a와 b를 구하는 작업

------



1. 임의로 정한 기울기 a와 y절편 b의 값이 각각 3과 76이라고 할 때 리스트 ab를 만들어 저장

   ```python
   ab = [3, 76]
   ```

2. 리스트 x와 리스트 y를 만들어 첫 번째 값을 리스트 x에 저장하고 두 번째 값을 리스트에 저장

   ```python
   data = [[2,81], [4,93], [6,91], [8,97]]
   x = [i[0] for i in data]
   y = [i[1] for i in data]
   ```

3. 일차 방정식 `y=ax+b`를 구현

   ```python
   def predict(x):
       return ab[0]*x + ab[1]
   ```

4. RMSE 공식 함수로 구현

   - *p*: 예측 값
   - *a*: 실제 값

   ```python
   def rmse(p, a):
   	return np.sqrt(((p-a)**2).mean())
   ```

5. rmse()에 데이터를 대입하여 최종값을 구하는 함수 구현

   - *predict_result*: predict()의 return 값이 들어감

   ```python
   def rmse_val(predict_result, y):
     return rmse(np.array(predict_result), np.array(y))
   ```

6. 예측 값을 담는 리스트 predict_result 구현

   ```python
   predict_result = list()
   
   for i in range(len(x)):
     predict_result.append(predict(x[i]))
     print(f'{x[i]}, {y[i]}, {predict(x[i])}')
   ```


- rmse.py

```python
import numpy as np

# 기울기 a와 y절편 b
ab = [3, 76]

# x, y의 데이터 값
data = [[2,81], [4,93], [6,91], [8,97]]
x = [i[0] for i in data]
y = [i[1] for i in data]

# y=ax+b에 a와 b 값을 대입하여 결과를 출력하는 함수
def predict(x):
  return ab[0]*x + ab[1]

# RMSE 함수
def rmse(p, a):
  return np.sqrt(((p-a)**2).mean())

# RMSE 함수를 각 y값에 대입해 최종값을 구하는 함수
def rmse_val(predict_result, y):
  return rmse(np.array(predict_result), np.array(y))

# 예측 값이 들어갈 빈 리스트
predict_result = list()

# 모든 x값을 한 번씩 대입하여 predict_result 리스트를 완성
for i in range(len(x)):
  predict_result.append(predict(x[i]))
  print(f'{x[i]}, {y[i]}, {predict(x[i])}')

# 최종 RMSE 출력
print(f'rmse 최종값: ' + str(rmse_val(predict_result, y)))

```
